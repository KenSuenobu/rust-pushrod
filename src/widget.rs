// Widget
// Pushrod
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::base_widget::BaseWidget;
use crate::box_widget::BoxWidget;
use crate::event::PushrodEvent;
use crate::geometry::{Point, Size};
use crate::texture::TextureStore;
use sdl2::pixels::Color;
use sdl2::render::{Canvas, Texture};
use sdl2::video::Window;
use std::any::Any;

/// `Widget` is a drawable, interactive object that is presented in a `Window`.
///
/// `Widget`s are components that are used to display information to a user, as well as to provide
/// user-interactable objects.  These make up things like text messages, images, 3D graphics, and
/// so on.
pub trait Widget {
    /// Returns the pure form of the object for casting, if required.  This is used internally by
    /// the `Pushrod` event system, and should always just return `self`.  (See #impl_widget_base
    /// macro)
    fn as_any(&self) -> &dyn Any;

    /// Gets the origin (upper left-hand) coordinate of the `Widget`.  This is the physical location
    /// of the `Widget` on the screen.
    fn get_origin(&self) -> &Point;

    /// Gets the `Size` (bounds) of the object in `width` and `height`.
    fn get_size(&self) -> &Size;

    /// Gets the color of the `Widget`.
    fn get_color(&self) -> Color;

    /// Sets the origin point.
    fn set_origin(&mut self, point: Point);

    /// Sets the size of the `Widget`.  Sub-`Widget` objects must also be resized.
    fn set_size(&mut self, size: Size);

    /// Sets the invalidation state of the object.  When invalidated, it indicates to the
    /// `Engine` that it needs to be refreshed in the main screen, or not.  Note, any `Widget`s that
    /// introduce multiple sub-`Widget`s into their drawing stack also need to be set invalidated
    /// when the top-level is set.  Otherwise, you may exhibit unwanted or odd behavior.
    fn set_invalidated(&mut self, state: bool);

    /// Sets the main color of the `Widget`.
    fn set_color(&mut self, color: Color);

    /// Indicates whether or not an object needs to be redrawn.  This only needs to be implemented
    /// on the top-level `Widget`, unless a sub-`Widget` object changes state based on a timer or
    /// some other reason.
    ///
    /// On an invalidation event, the system will call the `draw` method and re-draw its contents,
    /// saving that contents to a texture, and displaying it to the screen during the draw cycle.
    fn is_invalidated(&self) -> bool;

    /// Retrieves the `TextureStore` for the `Widget`.  The `TextureStore` is the object's
    /// drawing GPU texture that gets blitted to the screen.  Only update the texture if
    /// invalidated.
    fn get_texture(&mut self) -> &mut TextureStore;

    /// Function that responds to an event from SDL2, and generates an optional `PushrodEvent` as a
    /// result of the event.  Any events that the `Widget` implements should be captured here.
    /// This includes things like a mouse entering or exiting the bounds of the `Widget` control, or
    /// a keyboard keypress.
    ///
    /// If an event is generated by the `Widget` after handling an event, it should be returned as
    /// an optional return.  Otherwise, if the `Widget` consumes the event without generating a
    /// responding event, it should return `None`.  **Most** `Widget`s will return `None`, however,
    /// something like a timer or other widget could create a custom event.  If so, it should be
    /// returned here so that other `Widget` objects, or the underlying application, can handle
    /// the event appropriately.
    fn handle_event(&self, event: PushrodEvent) -> Option<&[PushrodEvent]>;

    /// Copies the image stored inside the `Widget` to the screen.  If the `Widget` doesn't
    /// actually _draw_ anything, it can return `None`.  Otherwise, it returns a reference
    /// to the stored `Texture`.
    ///
    /// Drawing is conducted from an origin of `x=0` and `y=0` as the base coordinates.  The only other
    /// bounds that should be referenced are the `size` coordinates, meaning the `width` and
    /// `height` of the object.
    ///
    /// All drawing is always done from an origin point, as the actual `Widget`'s `get_origin`
    /// point is indicated to the `Pushrod` system as to where the `Widget` should be drawn in
    /// the user viewable space (canvas).
    fn draw(&mut self, c: &mut Canvas<Window>) -> Option<&Texture>;
}

/// System Widgets.
pub enum SystemWidget {
    /// Stores a `BaseWidget`, one of the simplest drawing `Widget` objects.
    Base(Box<BaseWidget>),

    /// Stores a `BoxWidget`, an object that contains `BaseWidget` and draws a border with a width and color.
    Box(Box<BoxWidget>),

    /// Stores a custom `Widget`.
    Custom(Box<dyn Widget>),
}

/// impl_widget_base! macro is used as a shortcut for any `impl` that does not implement its own
/// custom functionality for any of the base functions in `Widget`, aside from `handle_event`
/// and `draw`.
///
/// Any functions that introduce this macro into the `impl` section of the `Widget` must create
/// the following support objects in the `struct` that defined the `Widget`:
///
/// ```rust,no_run
/// struct MyWidget {
///   origin: Point,
///   size: Size,
///   invalidated: bool,
///   in_bounds: bool,
///   texture: TextureStore,
///   base_widget: BaseWidget,
///   ...,
/// }
/// ```
///
/// Note, any `Widget` that is drawn must draw against the `base_widget`, which utilizes the
/// object inheritance using composition.
#[macro_export]
macro_rules! impl_widget_base {
    () => {
        fn as_any(&self) -> &dyn Any {
            self
        }

        fn get_origin(&self) -> &Point {
            &self.origin
        }

        fn get_size(&self) -> &Size {
            &self.size
        }

        fn get_color(&self) -> Color {
            self.base_widget.get_color()
        }

        fn set_origin(&mut self, point: Point) {
            self.origin = point;
        }

        fn set_size(&mut self, size: Size) {
            self.size = size;
            self.base_widget.set_size(size);
            self.set_invalidated(true);
        }

        fn set_invalidated(&mut self, state: bool) {
            self.invalidated = state;
            self.base_widget.set_invalidated(state);
        }

        fn set_color(&mut self, color: Color) {
            self.base_widget.set_color(color);
            self.set_invalidated(true);
        }

        fn is_invalidated(&self) -> bool {
            self.invalidated
        }

        fn get_texture(&mut self) -> &mut TextureStore {
            &mut self.texture
        }
    };
}
